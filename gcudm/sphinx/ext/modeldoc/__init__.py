#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Created by pat on 4/9/18
"""
.. currentmodule:: __init__.py
.. moduleauthor:: Pat Daburu <pat@daburu.net>

Say something descriptive about the '__init__.py' module.
"""

from sphinx.ext.autodoc import (
    ClassLevelDocumenter, AttributeDocumenter, ClassDocumenter
)
from sphinx.util.inspect import object_description, getdoc
from sphinx.util.docstrings import prepare_docstring
from sphinx.ext.autodoc import SUPPRESS
from six import text_type
from sphinx.util import force_decode
from sqlalchemy.sql.schema import Column


from ....model import IS_MODEL_CLASS
from ....meta import COLUMN_META_ATTR, TABLE_META_ATTR
from ....docstrings import ModelRstFormatter
import uuid

model_rst_formatter = ModelRstFormatter()

__version__ = '0.0.1'  #: the version of this Sphinx extension


def setup(app):
    # type: (Sphinx) -> Dict[unicode, Any]
    app.add_autodocumenter(ModelClassDocumenter)
    app.add_autodocumenter(ColumnAttributeDocumenter)
    return {'version': __version__, 'parallel_read_safe': True}


class ModelClassDocumenter(ClassDocumenter):

    def get_doc(self, encoding=None, ignore=1):
        # Get the doc as generated by the parent class.
        doc = super().get_doc(encoding=encoding, ignore=ignore)

        print(doc)

        # We only care about classes decorated as models.
        if not(hasattr(self.object, IS_MODEL_CLASS) and
               hasattr(self.object, TABLE_META_ATTR)):
            return doc

        img_sub = str(uuid.uuid4()).replace('-', '')
        lines = [[
            f".. |{img_sub}| image:: _static/images/table.svg",
            '    :width: 24px',
            '    :height: 24px',
            '',
            f"|{img_sub}|",
            self.object.__doc__ or '', '',
            f':Table Name: {self.object.__tablename__}', ''
            f':Geometry Type: {self.object.geometry_type()}', ''
        ]]
        return lines

#         lines = []
#         tbl_img_sub = f"img_tbl_{str(uuid.uuid4()).replace('-', '')}"
#         #Define the in-line table image.
#         lines.append(f'.. |{tbl_img_sub}| image:: _static/images/table.svg')
#         lines.append('\t:width: 24px')
#         lines.append('\t:height: 24px')
#
#         lines.append(f"|{tbl_img_sub}| {self.object.__doc__ or ''}")
#
#
#         #doc[0] = f'I AM A TABLE!!!! {doc[0]}'
#
#         #print(f'~~~~~~~~{doc[0]}')
#
# #        lines = model_rst_formatter.cls2rst(self.object)
#         print(lines)
#         return [lines]

        #return doc




        # # type: (unicode, int) -> List[List[unicode]]
        # lines = getattr(self, '_new_docstrings', None)
        # if lines is not None:
        #     return lines
        #
        # content = self.env.config.autoclass_content
        #
        # docstrings = []
        # attrdocstring = self.get_attr(self.object, '__doc__', None)
        # if attrdocstring:
        #     docstrings.append(attrdocstring)
        #
        # # for classes, what the "docstring" is can be controlled via a
        # # config value; the default is only the class docstring
        # if content in ('both', 'init'):
        #     initdocstring = self.get_attr(
        #         self.get_attr(self.object, '__init__', None), '__doc__')
        #     # for new-style classes, no __init__ means default __init__
        #     if (initdocstring is not None and
        #         (initdocstring == object.__init__.__doc__ or  # for pypy
        #          initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
        #         initdocstring = None
        #     if not initdocstring:
        #         # try __new__
        #         initdocstring = self.get_attr(
        #             self.get_attr(self.object, '__new__', None), '__doc__')
        #         # for new-style classes, no __new__ means default __new__
        #         if (initdocstring is not None and
        #             (initdocstring == object.__new__.__doc__ or  # for pypy
        #              initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
        #             initdocstring = None
        #     if initdocstring:
        #         if content == 'init':
        #             docstrings = [initdocstring]
        #         else:
        #             docstrings.append(initdocstring)
        # doc = []
        # for docstring in docstrings:
        #     if isinstance(docstring, text_type):
        #         doc.append(prepare_docstring(docstring, ignore))
        #     elif isinstance(docstring, str):  # this will not trigger on Py3
        #         doc.append(prepare_docstring(force_decode(docstring, encoding),
        #                                      ignore))
        #
        # print(f'***{doc}')
        #
        # return doc


class ColumnAttributeDocumenter(AttributeDocumenter):
    """
    This is a specialized Documenter subclass for attributes.  It overrides the
    parent class' behavior with special handling for :py:class:`Column`
    attributes.
    """
    def add_content(self, more_content, no_docstring=False):
        # type: (Any, bool) -> None
        # Remember the original no_docstring parameter.
        _no_docstring = no_docstring
        # If this attribute appears to be a Column...
        if (isinstance(self.object, Column)
                and hasattr(self.object, COLUMN_META_ATTR)):
            # ...we really want to document it.
            _no_docstring = False
        elif not self._datadescriptor:
            # if it's not a data descriptor, its docstring is very probably the
            # wrong thing to display
            _no_docstring = True
        ClassLevelDocumenter.add_content(self, more_content, _no_docstring)

    def get_doc(self, encoding=None, ignore=1):
        # type: (unicode, int) -> List[List[unicode]]
        """Decode and return lines of the docstring(s) for the object."""
        # If the current object is a Column and
        if (isinstance(self.object, Column) and
                hasattr(self.object, COLUMN_META_ATTR)):
            # Get the metadata from the column.
            meta = self.object.__meta__
            # Create the doc for the column.
            rst = model_rst_formatter.col2section(meta)
            return[prepare_docstring(rst, 0)]  # don't ignore it!
        else:  # In all other cases, let the parent class do its thing.
            return super().get_doc(encoding=encoding, ignore=ignore)




